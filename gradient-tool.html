<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">

    <title>Geostrophic Wind Ruler ¬∑ MB Sailing ‚Äì Yacht Delivery & Weather Routing</title>

    <!-- SEO / Metadata (MB Sailing ‚Äì Geostrophic Wind Ruler) -->
    <meta name="description" content="Geostrophisches Windlineal ‚Äì interaktives Tool zur Absch√§tzung von Druckgradienten, geostrophischem Wind und gesch√§tztem Bodenwind anhand von Isobarenabst√§nden. Praktisch f√ºr Segler, Yacht√ºberf√ºhrungen und Wetterrouting.">
    <meta name="keywords" content="geostrophischer Wind, Druckgradient, Isobaren, Wetterrouting, Yacht Delivery, Segeln, Navigation, MB Sailing, geostrophic wind calculator, pressure gradient tool">
    <meta name="author" content="Matthias Baier ‚Äì MB Sailing">
    <meta name="license" content="CC BY-NC 4.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- OG / Social Sharing -->
    <meta property="og:title" content="Geostrophisches Windlineal ‚Äì MB Sailing">
    <meta property="og:description" content="Interaktives Tool: aus Isobarenabst√§nden Druckgradient, geostrophischen Wind und gesch√§tzten Bodenwind bestimmen. F√ºr Segler & Navigation.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://mb-sailing.com/ydrs-Dateien/image009.jpg">
    <meta property="og:url" content="https://mb-sailing.com/geostrophic-wind-ruler.html">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Geostrophisches Windlineal ‚Äì MB Sailing">
    <meta name="twitter:description" content="Interaktives Tool zur praktischen meteorologischen Absch√§tzung f√ºr Segler.">
    <meta name="twitter:image" content="https://mb-sailing.com/ydrs-Dateien/image009.jpg">

    <!-- Google Fonts: IBM Plex Sans + IBM Plex Mono -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600&family=IBM+Plex+Mono:wght@300;400;500&display=swap" rel="stylesheet">

    <!-- Favicon ‚Äì wie in impressum.html -->
    <link rel="icon" type="image/png" sizes="32x32" href="impressum-Dateien/image008.png">
    <link rel="shortcut icon" href="impressum-Dateien/image008.png">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'IBM Plex Sans', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            line-height: 1.6;
            background-color: #f5f5f5;
            color: #222;
        }

        /* Header-/Seitenrahmen wie bisher */
        .page {
            max-width: 900px;
            margin: 0 auto;
            padding: 16px 20px 24px 20px;
            background-color: #ffffff;
        }

        .logo-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .logo {
            max-height: 40px;
            width: auto;
        }

        .nav {
            margin: 12px 0 18px;
            padding: 8px 0 10px;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 14px 20px;
            flex-wrap: wrap;
            font-size: 0.9rem;
        }

        .nav a {
            color: #666;
            text-decoration: none;
            border-bottom: 1px solid transparent;
            padding-bottom: 2px;
        }

        .nav a:hover {
            color: #0f766e;
            border-bottom-color: rgba(15, 118, 110, 0.4);
        }

        .nav a.active {
            font-weight: 600;
            color: #0f766e;
            border-bottom-color: #0f766e;
        }

        header img.hero {
            width: 100%;
            height: auto;
            display: block;
            margin-bottom: 6px;
        }

        .tagline {
            font-size: 0.8rem;
            text-align: right;
            color: #666;
            margin-bottom: 18px;
        }

        h1 {
            font-size: 1.6rem;
            margin-bottom: 0.4rem;
        }

        p {
            margin: 0 0 0.6rem;
            font-size: 0.95rem;
        }

        .muted {
            color: #666;
            font-size: 0.9rem;
        }

        footer {
            max-width: 900px;
            margin: 0 auto;
            padding: 12px 20px 24px;
            background: #ffffff;
            border-top: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 0.85rem;
            color: #666;
            flex-wrap: wrap;
        }

        footer .footer-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        a {
            color: #0f6ad0;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width: 600px) {
            .page {
                padding: 12px 14px 20px;
            }
            footer {
                padding: 10px 14px 20px;
            }
            .logo {
                max-height: 32px;
            }
            h1 {
                font-size: 1.4rem;
            }
        }

        /* --- Tool-Bereich: bricht aus dem schmalen Frame aus --- */

        .tool-shell {
            padding: 0 0 40px 0;
        }

        .tool-inner {
            max-width: 2000px;          /* hier spielt die Musik */
            margin: 0 auto;
            padding: 0 20px;
        }

        .tool-wrapper {
            margin-top: 1.2rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        #controls {
            background: #f9fafb;
            border-radius: 0.75rem;
            padding: 0.75rem 0.9rem;
            border: 1px solid #e5e7eb;
            font-size: 0.9rem;
        }

        #controls h3 {
            margin-top: 0;
            margin-bottom: 0.4rem;
            font-size: 1.05rem;
        }

        #controls p.small-hint {
            margin-top: 0;
            margin-bottom: 0.6rem;
            font-size: 0.8rem;
            color: #555;
        }

        #controls label {
            display: block;
            margin-top: 0.4rem;
        }

        #controls input[type="number"],
        #controls input[type="file"] {
            width: 100%;
            margin-top: 0.25rem;
            padding: 0.35rem 0.4rem;
            font-size: 0.88rem;
            font-family: inherit;
        }

        #controls button {
            width: 100%;
            margin-top: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.92rem;
            border-radius: 0.5rem;
            border: 1px solid #0f766e;
            background: #0f766e;
            color: white;
            font-weight: 500;
            cursor: pointer;
        }

        #controls button.mode-active {
            background: #115e59;
            border-color: #0f4f4a;
        }

        #status {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #374151;
        }

        #results {
            margin-top: 0.5rem;
            font-size: 0.88rem;
            line-height: 1.35;
        }

        #log {
            margin-top: 0.5rem;
            font-family: "IBM Plex Mono", Menlo, Consolas, monospace;
            white-space: pre-wrap;
            max-height: 160px;
            overflow-y: auto;
            background: #f3f4f6;
            border-radius: 0.5rem;
            padding: 0.4rem;
            border: 1px solid #e5e7eb;
            font-size: 0.78rem;
        }

        #canvasContainer {
            background: #f9fafb;
            border-radius: 0.75rem;
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            width: 100%;
        }

        #mapCanvas {
            display: block;
            width: 100% !important;
            height: auto;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db;
            background: #e5e7eb;
        }

        .surface-toggle {
            margin-top: 0.6rem;
            font-size: 0.85rem;
        }

        .surface-toggle span {
            display: block;
            margin-bottom: 0.15rem;
            color: #374151;
        }

        .surface-toggle label {
            display: inline-flex;
            align-items: center;
            margin-right: 0.8rem;
            margin-top: 0.15rem;
            cursor: pointer;
        }

        .surface-toggle input[type="radio"] {
            margin-right: 0.25rem;
        }

        @media (min-width: 900px) {
            .tool-wrapper {
                flex-direction: row;
                align-items: flex-start;
            }

            #controls {
                width: 320px;
                flex-shrink: 0;
            }

            #canvasContainer {
                flex: 1;
                margin-left: 0.75rem;
            }
        }
    </style>
</head>

<body>

<!-- HEADER-BEREICH im schmalen Frame -->
<div class="page">
    <header>
        <div class="logo-row">
            <a href="index.html">
                <img src="ydrs-Dateien/image011.png" alt="MB Sailing" class="logo">
            </a>
            <a href="#" class="email-link-header">
                <img src="ydrs-Dateien/image003.jpg" alt="Contact" class="logo">
            </a>
        </div>

        <nav class="nav">
            <a href="index.html">Start</a>
            <a href="ydrs.html">Yacht Delivery &amp; Weather Routing</a>
            <a href="regatta.html">Regatta Campaigns</a>
            <a href="past-projects.html">Past Projects</a>
            <a href="links.html">Links</a>
            <a href="datenschutz.html">Datenschutz</a>
            <a href="impressum.html">Impressum</a>
        </nav>

        <img src="ydrs-Dateien/image009.jpg" alt="Offshore sailing ‚Äì MB Sailing" class="hero">
        <div class="tagline">Photo: Ch. Mantel</div>

        <h1>Geostrophisches Windlineal</h1>
        <p class="muted">
            Aus Isobarenabst√§nden den Druckgradienten, den geostrophischen Wind und einen
            gesch√§tzten Bodenwind bestimmen ‚Äì direkt auf der Wetterkarte.
        </p>
    </header>
</div>

<!-- TOOL-BEREICH in voller Breite -->
<div class="tool-shell">
    <div class="tool-inner">
        <div class="tool-wrapper" id="gradient-tool">

            <div id="controls">
                <h3>Werkzeug</h3>
                <p class="small-hint">
                    1) Karte laden ¬∑ 2) Kalibrieren mit ŒîœÜ ¬∑ 3) Gradient mit zwei Isobarenpunkten messen.
                </p>

                <label>
                    Wetterkarte laden:
                    <input type="file" id="imageLoader" accept="image/*">
                </label>

                <label>
                    Breitenunterschied der Kalibrierstrecke (ŒîœÜ in ¬∞):
                    <input type="number" id="deltaPhiDeg" value="10" step="0.1">
                </label>

                <label>
                    Isobarenabstand (Œîp in hPa):
                    <input type="number" id="deltaP" value="5" step="0.1">
                </label>

                <label>
                    geographische Breite des Gebiets (œÜ in ¬∞, f√ºr f):
                    <input type="number" id="phiDeg" value="45" step="0.1">
                </label>

                <label>
                    Luftdichte œÅ (kg/m¬≥, optional):
                    <input type="number" id="rho" value="1.25" step="0.01">
                </label>

                <div class="surface-toggle">
                    <span>Untergrund f√ºr Bodenwind-Sch√§tzung:</span>
                    <label>
                        <input type="radio" name="surface" id="surfaceSea" value="sea" checked>
                        √úber See (‚âà 70&nbsp;% v<sub>g</sub>)
                    </label>
                    <label>
                        <input type="radio" name="surface" id="surfaceLand" value="land">
                        √úber Land (‚âà 60&nbsp;% v<sub>g</sub>)
                    </label>
                </div>

                <button id="btnCalibrate">1) Kalibrieren (2 Punkte mit bekanntem ŒîœÜ klicken)</button>
                <button id="btnMeasure">2) Gradient messen (2 Punkte auf Isobaren klicken)</button>

                <div id="status"></div>

                <h4>Ergebnisse</h4>
                <div id="results"></div>

                <h4>Log</h4>
                <div id="log"></div>
            </div>

            <div id="canvasContainer">
                <canvas id="mapCanvas"></canvas>
            </div>

        </div>
    </div>
</div>

<!-- Lizenz- und Zweckhinweis -->
<div class="page" style="font-size:0.8rem; color:#555; margin-top:2rem; text-align:left;">
    <p>
        <strong>√úber dieses Werkzeug:</strong><br>
        Dieses geostrophische Windlineal dient zur vereinfachten Absch√§tzung des Druckgradienten,
        des geostrophischen Windes und eines gesch√§tzten Bodenwindes anhand von Isobarenabst√§nden.
        Ein Lehr- und Arbeitstool f√ºr Segelpraxis, Wetterrouting & Navigation.
    </p>
	<p style="font-size:0.78rem; color:#666; margin-top:0.5rem;">
		Hinweis: Dieses Tool vereinfacht meteorologische Zusammenh√§nge und ersetzt keine offiziellen Wetterwarnungen,
		See- oder Luftfahrtinformationen. Entscheidungen √ºber Navigation und Betrieb verbleiben stets an Bord.
	</p>

    <p style="margin:0.4rem 0 0;">
        Lizenz: <strong>Creative Commons BY-NC 4.0</strong> ‚Äî Namensnennung erforderlich,
        keine kommerzielle Weitergabe oder Nutzung ohne vorherige Zustimmung.<br>
        ¬© 2017‚Äì2025 Matthias Baier ¬∑ MB Sailing ‚Äì All Oceans
    </p>

    <p style="margin-top:0.3rem;">
        üîó Lizenzdetails:
        <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.de" target="_blank" rel="noopener">
            https://creativecommons.org/licenses/by-nc/4.0/
        </a>
    </p>
</div>

<footer>
    <div class="footer-row">
        <span>¬© 2017‚Äì2025 ¬∑ Matthias Baier</span>
        <span class="muted">MB Sailing ‚Äì All Oceans</span>
    </div>

    <div style="font-size:0.75rem; color:#777; text-align:right; width:100%;">
        <span>
            <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.de" target="_blank" rel="noopener"
               style="text-decoration:none; color:#0f6ad0; border-bottom:1px solid rgba(15,106,208,0.3);">
                CC BY-NC 4.0
            </a> ¬∑ MB Sailing üúÅ
        </span>
    </div>

    <p style="font-size:0.75rem; color:#666; margin-top:6px;">
        Suchbegriffe: Geostrophischer Wind berechnen ¬∑ Druckgradient messen ¬∑
        Wind aus Isobarenabstand ¬∑ Yacht Wetterrouting ¬∑ MB Sailing Tools
    </p>
</footer>

<script>
    // E-Mail wie in impressum.html
    (function () {
        const user = "alloceans";
        const domain = "mb-sailing.com";
        const email = user + "@" + domain;

        const headerLink = document.querySelector(".email-link-header");
        if (headerLink) {
            headerLink.href = "mailto:" + email;
        }
    })();
</script>

<script>
    // --- JS f√ºr das geostrophische Windlineal ---

    const imageLoader = document.getElementById('imageLoader');
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');

    const btnCalibrate = document.getElementById('btnCalibrate');
    const btnMeasure   = document.getElementById('btnMeasure');
    const statusDiv    = document.getElementById('status');
    const resultsDiv   = document.getElementById('results');
    const logDiv       = document.getElementById('log');

    const surfaceSeaRadio  = document.getElementById('surfaceSea');
    const surfaceLandRadio = document.getElementById('surfaceLand');

    let img = new Image();
    let mode = null;
    let clickPoints = [];
    let kmPerPixel = null;

    function log(msg) {
        logDiv.textContent += msg + "\n";
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // Bild laden ‚Äì Karte bekommt die volle Breite des Tool-Containers
    imageLoader.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            img = new Image();
            img.onload = function() {
                const container = document.getElementById('canvasContainer');
                const containerWidth = container ? container.clientWidth : (window.innerWidth - 40);

                const targetWidth = Math.min(containerWidth, img.width);
                const scale = targetWidth / img.width;

                canvas.width  = img.width * scale;
                canvas.height = img.height * scale;

                redrawCanvas();
                log("Bild geladen: " + img.width + " x " + img.height + " px, " +
                    "Canvas: " + canvas.width + " x " + canvas.height + " px");
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }, false);

    function setMode(newMode) {
        mode = newMode;
        clickPoints = [];
        statusDiv.textContent = newMode === "calibrate"
            ? "Modus: Kalibrieren ‚Äì zwei Punkte mit bekanntem Breitenabstand w√§hlen."
            : "Modus: Gradient messen ‚Äì zwei Punkte auf benachbarten Isobaren w√§hlen.";
        btnCalibrate.classList.toggle('mode-active', mode === "calibrate");
        btnMeasure.classList.toggle('mode-active',   mode === "measure");
        redrawCanvas();
    }

    btnCalibrate.addEventListener('click', () => setMode("calibrate"));
    btnMeasure.addEventListener('click', () => {
        if (kmPerPixel == null) {
            alert("Bitte zuerst kalibrieren.");
            return;
        }
        setMode("measure");
    });

    canvas.addEventListener('click', function(e) {
        if (!mode || !img || !img.complete) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        clickPoints.push({x, y});
        if (clickPoints.length > 2) {
            clickPoints = clickPoints.slice(-2);
        }
        redrawCanvas();

        if (clickPoints.length === 2) {
            if (mode === "calibrate") {
                handleCalibration();
            } else if (mode === "measure") {
                handleMeasurement();
            }
            clickPoints = [];
            redrawCanvas();
        }
    });

    function pixelDistance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx*dx + dy*dy);
    }

    function niceScaleLength(kmTarget) {
        if (!kmTarget || kmTarget <= 0) return 10;
        const exponent = Math.floor(Math.log10(kmTarget));
        const base = kmTarget / Math.pow(10, exponent);
        let niceBase;
        if      (base < 1.5) niceBase = 1;
        else if (base < 3.5) niceBase = 2;
        else if (base < 7.5) niceBase = 5;
        else                 niceBase = 10;
        return niceBase * Math.pow(10, exponent);
    }

    function drawScaleBar() {
        if (!kmPerPixel) return;

        const marginX = 60;
        const marginY = 50;
        const y = canvas.height - marginY;
        const targetPx = canvas.width * 0.25;
        const targetKm = targetPx * kmPerPixel;
        const barKm = niceScaleLength(targetKm);
        const barPx = barKm / kmPerPixel;

        const segments = 5;
        const segmentPx = barPx / segments;
        const segmentKm = barKm / segments;

        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = "black";
        ctx.fillStyle = "black";
        ctx.font = Math.max(12, canvas.width * 0.02) + "px 'IBM Plex Sans', sans-serif";

        ctx.beginPath();
        ctx.moveTo(marginX, y);
        ctx.lineTo(marginX + barPx, y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(marginX, y - 8);
        ctx.lineTo(marginX, y + 8);
        ctx.moveTo(marginX + barPx, y - 8);
        ctx.lineTo(marginX + barPx, y + 8);
        ctx.stroke();

        ctx.lineWidth = 2;
        for (let i = 1; i < segments; i++) {
            const x = marginX + segmentPx * i;
            ctx.beginPath();
            ctx.moveTo(x, y - 6);
            ctx.lineTo(x, y + 6);
            ctx.stroke();
            ctx.fillText(`${(segmentKm * i).toFixed(0)} km`, x - 18, y - 12);
        }

        ctx.fillText("0 km", marginX - 10, y - 12);
        ctx.fillText(`${barKm.toFixed(0)} km`, marginX + barPx - 22, y - 12);

        ctx.restore();
    }

    function redrawCanvas() {
        if (!img || !img.complete || canvas.width === 0) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        if (kmPerPixel) {
            drawScaleBar();
        }

        if (clickPoints.length > 0) {
            ctx.save();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#ff0000";
            ctx.fillStyle = "#ff0000";

            clickPoints.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                ctx.stroke();
            });

            if (clickPoints.length === 2) {
                ctx.beginPath();
                ctx.moveTo(clickPoints[0].x, clickPoints[0].y);
                ctx.lineTo(clickPoints[1].x, clickPoints[1].y);
                ctx.strokeStyle = "#00aa00";
                ctx.stroke();
            }
            ctx.restore();
        }
    }

    function handleCalibration() {
        const p1 = clickPoints[0];
        const p2 = clickPoints[1];
        const distPx = pixelDistance(p1, p2);
        const deltaPhiDeg = parseFloat(document.getElementById('deltaPhiDeg').value);

        if (!deltaPhiDeg || distPx === 0) {
            alert("Bitte ŒîœÜ und sinnvolle Punkte w√§hlen.");
            return;
        }

        const kmPerDeg = 111.2;
        const distKm = deltaPhiDeg * kmPerDeg;
        const kmPerPxLocal = distKm / distPx;
        kmPerPixel = kmPerPxLocal;

        log(`Kalibrierung: ŒîœÜ = ${deltaPhiDeg}¬∞, Pixelabstand = ${distPx.toFixed(1)} px, ` +
            `‚Üí ${kmPerPixel.toFixed(3)} km/px`);

        statusDiv.textContent = "Kalibriert. Nun Gradient messen.";
    }

    function msToBeaufort(v_ms) {
        const thresholds = [0.3, 1.6, 3.4, 5.5, 8.0, 10.8, 13.9, 17.2, 20.8, 24.5, 28.5, 32.7];
        const names = [
            "Windstille",
            "Leiser Zug",
            "Leichte Brise",
            "Schwache Brise",
            "M√§√üige Brise",
            "Frische Brise",
            "Starker Wind",
            "Steifer Wind",
            "St√ºrmischer Wind",
            "Sturm",
            "Schwerer Sturm",
            "Orkanartiger Sturm",
            "Orkan"
        ];

        let bft = 0;
        while (bft < thresholds.length && v_ms >= thresholds[bft]) {
            bft++;
        }
        return { bft, name: names[bft] };
    }

    function handleMeasurement() {
        const p1 = clickPoints[0];
        const p2 = clickPoints[1];
        const distPx = pixelDistance(p1, p2);
        const distKm = distPx * kmPerPixel;
        const distM  = distKm * 1000;

        const deltaP_hPa = parseFloat(document.getElementById('deltaP').value);
        const phiDeg     = parseFloat(document.getElementById('phiDeg').value);
        const rho        = parseFloat(document.getElementById('rho').value) || 1.25;

        if (!deltaP_hPa || !phiDeg) {
            alert("Bitte Œîp und œÜ angeben.");
            return;
        }

        const deltaP_Pa = deltaP_hPa * 100.0;
        const gradP = deltaP_Pa / distM;

        const Omega = 7.2921e-5;
        const phiRad = phiDeg * Math.PI / 180.0;
        const f = 2 * Omega * Math.sin(phiRad);

        const v_g      = gradP / (rho * f);
        const v_kts    = v_g * 1.94384;
        const v_kmh    = v_g * 3.6;
        const bftInfo  = msToBeaufort(v_g);

        let factorSurf, surfLabel;
        if (surfaceLandRadio.checked) {
            factorSurf = 0.6;
            surfLabel = "√ºber Land";
        } else {
            factorSurf = 0.7;
            surfLabel = "√ºber See";
        }

        const v_surf      = v_g * factorSurf;
        const v_surf_kts  = v_surf * 1.94384;
        const v_surf_kmh  = v_surf * 3.6;
        const bftSurf     = msToBeaufort(v_surf);

        log(
            `Messung: Œîp = ${deltaP_hPa} hPa, Abstand = ${distKm.toFixed(1)} km ` +
            `‚Üí |‚àÇp/‚àÇn| = ${gradP.toExponential(3)} Pa/m, ` +
            `v_g ‚âà ${v_g.toFixed(1)} m/s (${v_kts.toFixed(1)} kt, Bft ${bftInfo.bft}), ` +
            `${surfLabel}: ‚âà ${v_surf.toFixed(1)} m/s (${v_surf_kts.toFixed(1)} kt, Bft ${bftSurf.bft})`
        );

        resultsDiv.innerHTML =
            `<b>Druckgradient:</b> ${gradP.toExponential(3)} Pa/m<br>` +
            `<b>Geostrophischer Wind:</b> ${v_g.toFixed(1)} m/s ` +
              `(${v_kmh.toFixed(1)} km/h, ${v_kts.toFixed(1)} kt), ` +
              `Bft ${bftInfo.bft} ‚Äì ${bftInfo.name}<br>` +
            `<b>Gesch√§tzter Bodenwind (${surfLabel}, ` +
              `${Math.round(factorSurf * 100)}&nbsp;% v<sub>g</sub>):</b> ` +
              `${v_surf.toFixed(1)} m/s ` +
              `(${v_surf_kmh.toFixed(1)} km/h, ${v_surf_kts.toFixed(1)} kt), ` +
              `Bft ${bftSurf.bft} ‚Äì ${bftSurf.name}`;

        statusDiv.textContent = "Messung abgeschlossen. Du kannst weitere Paare klicken.";
    }
</script>

</body>
</html>
